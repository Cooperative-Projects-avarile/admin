import {
  require_react
} from "./chunk-TYPHHKYZ.js";
import {
  __commonJS
} from "./chunk-ZS7NZCD4.js";

// ../../node_modules/.pnpm/great-async@1.0.6/node_modules/great-async/dist/common.js
var require_common = __commonJS({
  "../../node_modules/.pnpm/great-async@1.0.6/node_modules/great-async/dist/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FalsyValue = exports.shallowEqual = void 0;
    var shallowEqual = (arr1, arr2) => {
      if (!Array.isArray(arr1) || !Array.isArray(arr2)) {
        return false;
      }
      if (arr1.length !== arr2.length) {
        return false;
      }
      return arr1.every((a1, index) => a1 === arr2[index]);
    };
    exports.shallowEqual = shallowEqual;
    var FalsyValue = class {
      constructor(v) {
        this.v = v;
      }
      getValue() {
        return this.v;
      }
    };
    exports.FalsyValue = FalsyValue;
  }
});

// ../../node_modules/.pnpm/great-async@1.0.6/node_modules/great-async/dist/LRU.js
var require_LRU = __commonJS({
  "../../node_modules/.pnpm/great-async@1.0.6/node_modules/great-async/dist/LRU.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRU = void 0;
    var LRU = class extends Map {
      constructor(capacity) {
        super();
        this.capacity = capacity;
      }
      get(key) {
        const res = super.get(key);
        if (res !== void 0) {
          this.delete(key);
          this.set(key, res);
        }
        return res;
      }
      set(key, value) {
        this.get(key);
        super.set(key, value);
        if (this.size > this.capacity) {
          const outKey = this.keys().next().value;
          this.delete(outKey);
        }
        return this;
      }
    };
    exports.LRU = LRU;
  }
});

// ../../node_modules/.pnpm/great-async@1.0.6/node_modules/great-async/dist/asyncController.js
var require_asyncController = __commonJS({
  "../../node_modules/.pnpm/great-async@1.0.6/node_modules/great-async/dist/asyncController.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAsyncController = exports.DEFAULT_SINGLE_KEY = exports.DEFAULT_TIMER_KEY = exports.DIMENSIONS = exports.cacheMap = void 0;
    var common_1 = require_common();
    var LRU_1 = require_LRU();
    exports.cacheMap = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : /* @__PURE__ */ new Map();
    function createClearExpiredCache(fn, ttl) {
      let timer = null;
      return function clearExpiredCache() {
        if (timer) {
          clearTimeout(timer);
        }
        timer = setTimeout(() => {
          const fnCache = exports.cacheMap.get(fn);
          if (!fnCache) {
            return;
          }
          const now = Date.now();
          fnCache.forEach((value, key) => {
            if (now - value.timestamp > ttl) {
              fnCache.delete(key);
            }
          });
        });
      };
    }
    function clearCache(fn, key) {
      const fnCache = exports.cacheMap.get(fn);
      if (!fnCache) {
        return;
      }
      if (key) {
        fnCache.delete(key);
      } else {
        fnCache.clear();
      }
    }
    function defaultGenKeyByParams(params) {
      try {
        return JSON.stringify(params);
      } catch (error) {
        console.warn("great-async: serialize parameters failed!");
        return "[]";
      }
    }
    var DIMENSIONS;
    (function(DIMENSIONS2) {
      DIMENSIONS2[DIMENSIONS2["FUNCTION"] = 0] = "FUNCTION";
      DIMENSIONS2[DIMENSIONS2["PARAMETERS"] = 1] = "PARAMETERS";
    })(DIMENSIONS = exports.DIMENSIONS || (exports.DIMENSIONS = {}));
    exports.DEFAULT_TIMER_KEY = Symbol("DEFAULT_TIMER_KEY");
    exports.DEFAULT_SINGLE_KEY = Symbol("DEFAULT_SINGLE_KEY");
    function createAsyncController(fn, { debounceTime = -1, debounceDimension = DIMENSIONS.FUNCTION, ttl = -1, single = false, singleDimension = DIMENSIONS.FUNCTION, retryCount = 0, retryStrategy = (error) => !!error, genKeyByParams = defaultGenKeyByParams, cacheCapacity = -1, beforeRun } = {}) {
      let timerMapOfDebounce = /* @__PURE__ */ new Map();
      let promiseHandlerMap = /* @__PURE__ */ new Map();
      const clearExpiredCache = createClearExpiredCache(fnProxy, ttl);
      let listener = [];
      function retryFn(params, _retryCount = 0) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const res = yield fn(...params);
            return res;
          } catch (error) {
            if (_retryCount > 0 && retryStrategy(error)) {
              return retryFn(params, _retryCount - 1);
            }
            throw error;
          }
        });
      }
      function fnProxy(...params) {
        const key = genKeyByParams(params);
        if (ttl !== -1) {
          clearExpiredCache();
          const thisCache = exports.cacheMap.get(fnProxy);
          const cacheObj = thisCache === null || thisCache === void 0 ? void 0 : thisCache.get(key);
          if (cacheObj && Date.now() - cacheObj.timestamp < ttl) {
            return Promise.resolve(cacheObj.data);
          }
        }
        if (cacheCapacity !== -1) {
          const thisCache = exports.cacheMap.get(fnProxy);
          const cacheObj = thisCache === null || thisCache === void 0 ? void 0 : thisCache.get(key);
          if (cacheObj) {
            return Promise.resolve(cacheObj.data);
          }
        }
        if (single && debounceTime === -1) {
          if (singleDimension === DIMENSIONS.FUNCTION && promiseHandlerMap.get(exports.DEFAULT_SINGLE_KEY)) {
            return promiseHandlerMap.get(exports.DEFAULT_SINGLE_KEY);
          }
          if (singleDimension === DIMENSIONS.PARAMETERS && promiseHandlerMap.get(key)) {
            return promiseHandlerMap.get(key);
          }
        }
        const promiseHandler = new Promise((resolve, reject) => {
          if (debounceTime === -1) {
            return resolve();
          }
          listener.push({
            resolve,
            reject
          });
          if (debounceDimension === DIMENSIONS.FUNCTION) {
            clearTimeout(timerMapOfDebounce.get(exports.DEFAULT_TIMER_KEY));
            timerMapOfDebounce.set(exports.DEFAULT_TIMER_KEY, setTimeout(resolve, debounceTime));
          }
          if (debounceDimension === DIMENSIONS.PARAMETERS) {
            clearTimeout(timerMapOfDebounce.get(key));
            timerMapOfDebounce.set(key, setTimeout(resolve, debounceTime));
          }
        }).then((arg) => {
          if (arg === void 0) {
            beforeRun === null || beforeRun === void 0 ? void 0 : beforeRun();
            return retryFn(params, retryCount).then((res) => {
              var _a;
              const thisCache = exports.cacheMap.get(fnProxy);
              if (thisCache && (ttl !== -1 || cacheCapacity !== -1) && ((_a = thisCache.get(key)) === null || _a === void 0 ? void 0 : _a.data) !== res) {
                thisCache.set(key, {
                  data: res,
                  timestamp: Date.now()
                });
              }
              listener.forEach((i) => {
                i.resolve(res || new common_1.FalsyValue(res));
              });
              return res;
            }).catch((e) => {
              listener.forEach((i) => {
                i.reject(e);
              });
              throw e;
            });
          }
          return arg instanceof common_1.FalsyValue ? arg.getValue() : arg;
        }).finally(() => {
          timerMapOfDebounce.delete(exports.DEFAULT_TIMER_KEY);
          timerMapOfDebounce.delete(key);
          promiseHandlerMap.delete(exports.DEFAULT_SINGLE_KEY);
          promiseHandlerMap.delete(key);
          listener = [];
        });
        if (singleDimension === DIMENSIONS.FUNCTION) {
          promiseHandlerMap.set(exports.DEFAULT_SINGLE_KEY, promiseHandler);
        } else {
          promiseHandlerMap.set(key, promiseHandler);
        }
        return promiseHandler;
      }
      exports.cacheMap.set(fnProxy, cacheCapacity === -1 ? /* @__PURE__ */ new Map() : new LRU_1.LRU(cacheCapacity));
      function fnClearCache(...params) {
        clearCache(fnProxy, params.length ? genKeyByParams(params) : void 0);
      }
      fnProxy.clearCache = fnClearCache;
      return fnProxy;
    }
    exports.createAsyncController = createAsyncController;
  }
});

// ../../node_modules/.pnpm/great-async@1.0.6/node_modules/great-async/dist/useAsyncFunction.js
var require_useAsyncFunction = __commonJS({
  "../../node_modules/.pnpm/great-async@1.0.6/node_modules/great-async/dist/useAsyncFunction.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useAsyncFunction = void 0;
    var asyncController_1 = require_asyncController();
    var react_1 = require_react();
    var common_1 = require_common();
    var initDeps = [];
    var useAsyncFunction = (asyncFn, opts = {}) => {
      const { deps, manual, auto = true } = opts, createAsyncControllerOptions = __rest(opts, ["deps", "manual", "auto"]);
      const stateRef = (0, react_1.useRef)({
        isMounted: false,
        depsRef: initDeps,
        id: {}
      });
      const argsRef = (0, react_1.useRef)({
        asyncFn,
        deps: void 0,
        manual,
        auto: true
      });
      const [createAsyncControllerOpts] = (0, react_1.useState)(createAsyncControllerOptions);
      const [asyncFunctionState, setAsyncFunctionState] = (0, react_1.useState)({
        loading: manual === void 0 ? auto : !manual,
        error: null,
        data: null
      });
      argsRef.current.asyncFn = asyncFn;
      argsRef.current.manual = manual;
      argsRef.current.auto = auto;
      argsRef.current.deps = deps;
      if (deps && !Array.isArray(deps)) {
        console.log("deps:", JSON.stringify(deps));
        throw new Error("The deps must be an Array!");
      }
      const fnProxy = (0, react_1.useMemo)(() => {
        const fn1 = (...args) => argsRef.current.asyncFn(...args);
        return (0, asyncController_1.createAsyncController)(fn1, Object.assign(Object.assign({}, createAsyncControllerOpts), { beforeRun: createAsyncControllerOpts.debounceTime !== -1 || createAsyncControllerOpts.beforeRun ? () => {
          var _a;
          setAsyncFunctionState((ov) => {
            if (ov.loading) {
              return ov;
            }
            return Object.assign(Object.assign({}, ov), { loading: true });
          });
          (_a = createAsyncControllerOpts.beforeRun) === null || _a === void 0 ? void 0 : _a.call(createAsyncControllerOpts);
        } : void 0 }));
      }, [createAsyncControllerOpts]);
      const createRunFn = (0, react_1.useCallback)((throwError) => {
        return (...args) => __awaiter(void 0, void 0, void 0, function* () {
          yield Promise.resolve();
          if (createAsyncControllerOpts.debounceTime === -1) {
            setAsyncFunctionState((ov) => {
              if (ov.loading) {
                return ov;
              }
              return Object.assign(Object.assign({}, ov), { loading: true });
            });
          }
          try {
            const res = yield fnProxy(...args);
            setAsyncFunctionState((ov) => {
              if (!ov.loading && ov.error === null && ov.data === res) {
                return ov;
              }
              return {
                loading: false,
                error: null,
                data: res
              };
            });
            return res;
          } catch (err) {
            setAsyncFunctionState((ov) => {
              if (!ov.loading && ov.error === err && ov.data === null) {
                return ov;
              }
              return {
                error: err,
                loading: false,
                data: null
              };
            });
            if (throwError) {
              throw err;
            }
          }
        });
      }, [fnProxy]);
      const runFn = (0, react_1.useMemo)(() => createRunFn(false), [createRunFn]);
      const manualRunFn = (0, react_1.useMemo)(() => createRunFn(true), [createRunFn]);
      (0, react_1.useEffect)(() => {
        var _a;
        const ld = argsRef.current.deps;
        if (ld === null || ld === void 0 ? void 0 : ld.length) {
          stateRef.current.depsRef = ld;
        }
        stateRef.current.isMounted = true;
        if ((_a = argsRef.current.manual) !== null && _a !== void 0 ? _a : !auto) {
          return;
        }
        runFn();
      }, [runFn]);
      (0, react_1.useEffect)(() => {
        var _a;
        if (!stateRef.current.isMounted || stateRef.current.depsRef === initDeps) {
          return;
        }
        const ld = argsRef.current.deps;
        if ((0, common_1.shallowEqual)(ld, stateRef.current.depsRef)) {
          return;
        }
        stateRef.current.depsRef = ld;
        if ((_a = argsRef.current.manual) !== null && _a !== void 0 ? _a : !auto) {
          return;
        }
        runFn();
      }, [deps, runFn]);
      return {
        data: asyncFunctionState.data,
        loading: asyncFunctionState.loading,
        error: asyncFunctionState.error,
        run: manualRunFn,
        fn: manualRunFn,
        clearCache: fnProxy.clearCache
      };
    };
    exports.useAsyncFunction = useAsyncFunction;
  }
});

// ../../node_modules/.pnpm/great-async@1.0.6/node_modules/great-async/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/great-async@1.0.6/node_modules/great-async/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_common(), exports);
    __exportStar(require_asyncController(), exports);
    __exportStar(require_useAsyncFunction(), exports);
  }
});
export default require_dist();
//# sourceMappingURL=great-async.js.map
